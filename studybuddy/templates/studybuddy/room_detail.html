{% extends 'studybuddy/base.html' %}
{% block title %}{{ room.name }}{% endblock %}
{% block content %}
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
    <h2 style="margin:0;">{{ room.name }}</h2>
    {% if room.created_by == request.user %}
    <a href="{% url 'studybuddy:room_delete' room.id %}" 
       style="background-color:#dc2626;color:white;padding:8px 16px;border-radius:8px;text-decoration:none;font-size:14px;">
        Delete Room
    </a>
    {% endif %}
</div>

{% if room.created_by == request.user %}
<div id="privacy-controls" style="margin-bottom:20px;padding:15px;background-color:#eef2ff;border-radius:10px;">
    <p id="privacy-status" style="margin:0 0 10px 0;color:#1e3a8a;">
        This room is currently <strong>{% if room.is_private %}private{% else %}public{% endif %}</strong>.
    </p>
    <button id="togglePrivacyBtn"
            style="background-color:{% if room.is_private %}#16a34a{% else %}#2563eb{% endif %};color:white;padding:8px 16px;border:none;border-radius:8px;cursor:pointer;">
        {% if room.is_private %}Make Public{% else %}Make Private{% endif %}
    </button>
    <form id="privacyPasswordForm" style="margin-top:12px;display:none;">
        <input type="password" id="privacyPasswordInput" placeholder="New room password" required
               style="padding:8px;border-radius:6px;border:1px solid #cbd5f5;margin-right:8px;">
        <button type="submit"
                style="background-color:#1d4ed8;color:white;padding:8px 14px;border:none;border-radius:6px;cursor:pointer;">
            Confirm
        </button>
    </form>
    <p id="privacyError" style="display:none;color:#dc2626;margin-top:8px;"></p>
</div>
{% else %}
<div style="margin-bottom:20px;padding:12px;border-radius:8px;background-color:#f3f4f6;color:#374151;">
    This room is {% if room.is_private %}<strong>private</strong>{% else %}<strong>public</strong>{% endif %}.
</div>
{% endif %}

<div style="display:flex;gap:20px;">
    <!-- Chat Section -->
    <div style="flex:2;">
        <div id="chat-messages" style="border:1px solid #ddd;padding:15px;border-radius:8px;height:400px;overflow-y:auto;margin-bottom:15px;">
            {% for message in messages %}
                <div data-message-id="{{ message.id }}" data-timestamp-iso="{{ message.timestamp|date:'c' }}" style="margin-bottom:15px;padding:10px 15px;border-radius:10px;max-width:70%;word-wrap:break-word;position:relative;
                    {% if message.user == request.user %}background-color:#2563eb;color:white;margin-left:auto;{% else %}background-color:#e5e7eb;color:#111;{% endif %}">
                    <div style="display:flex;justify-content:space-between;align-items:start;">
                        <div style="flex:1;">
                            <strong>{{ message.user.username }}</strong><br>
                            {{ message.content }}
                            <div class="message-timestamp" style="font-size:0.8em;{% if message.user == request.user %}color:#e0e0e0;{% else %}color:#555;{% endif %}margin-top:4px;">
                                {{ message.timestamp|date:"M d, Y H:i" }}
                            </div>
                        </div>
                        {% if message.user == request.user %}
                        <button type="button" 
                                onclick="deleteMessage({{ message.id }})"
                                style="background-color:transparent;border:none;color:white;cursor:pointer;font-size:18px;padding:0;line-height:1;margin-left:10px;"
                                title="Delete message">
                            ×
                        </button>
                        {% endif %}
                    </div>
                </div>
            {% empty %}
                <p id="no-messages">No messages yet. Start the conversation!</p>
            {% endfor %}
        </div>

        <form id="message-form" style="display:flex;align-items:center;">
            {% csrf_token %}
            <textarea id="message-input" name="content" rows="2" placeholder="Type your message..." required
                      style="flex:1;resize:none;padding:10px;border-radius:8px;border:1px solid #ccc;font-family:inherit;"></textarea>
            <button type="submit"
                    style="background-color:#2563eb;border:none;color:white;padding:10px 20px;border-radius:8px;margin-left:10px;cursor:pointer;">
                Send
            </button>
        </form>
    </div>

    <!-- Pomodoro Timer Section -->
    <div style="flex:1;min-width:250px;">
        <div style="border:1px solid #ddd;padding:20px;border-radius:8px;background-color:#f8f9fa;">
            <h3 style="margin-top:0;text-align:center;color:#333;">Pomodoro Timer</h3>
            {% if room.created_by != request.user %}
            <div style="background-color:#fef3c7;padding:8px;border-radius:6px;margin-bottom:15px;text-align:center;font-size:12px;color:#92400e;">
                Only {{ room.created_by.username }} (room creator) can control the timer
            </div>
            {% endif %}
            
            <div id="timer-display" style="font-size:48px;font-weight:bold;text-align:center;margin:20px 0;color:#2563eb;">
                25:00
            </div>
            
            <div style="text-align:center;margin-bottom:15px;">
                <span id="timer-mode" style="font-size:16px;color:#666;">Work Session</span>
            </div>
            
            {% if room.created_by == request.user %}
            <div style="display:flex;flex-direction:column;gap:10px;">
                <button id="start-btn" onclick="startTimer()" 
                        style="background-color:#16a34a;color:white;padding:12px;border:none;border-radius:8px;cursor:pointer;font-size:16px;">
                    Start
                </button>
                <button id="pause-btn" onclick="pauseTimer()" 
                        style="background-color:#f59e0b;color:white;padding:12px;border:none;border-radius:8px;cursor:pointer;font-size:16px;display:none;">
                    Pause
                </button>
                <button onclick="resetTimer()" 
                        style="background-color:#6b7280;color:white;padding:12px;border:none;border-radius:8px;cursor:pointer;font-size:16px;">
                    Reset
                </button>
            </div>
            {% else %}
            <div style="text-align:center;padding:12px;background-color:#e5e7eb;border-radius:8px;color:#666;font-size:14px;">
                Timer controlled by room creator
            </div>
            {% endif %}
            
            <div style="margin-top:15px;padding:10px;background-color:#e5e7eb;border-radius:8px;font-size:14px;">
                <strong>Settings:</strong><br>
                Work: 25 min<br>
                Break: 5 min<br>
                <div style="margin-top:5px;font-size:12px;color:#666;">
                    <em>Synced across all users in room</em>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const ROOM_ID = {{ room.id }};
const IS_CREATOR = {{ room.created_by.id }} === {{ request.user.id }};
let pollInterval = null;
let messagePollInterval = null;
let lastMode = 'work';
let lastMessageId = null;
const privacyEndpoint = `/studybuddy/room/${ROOM_ID}/set_privacy/`;
let roomIsPrivate = {{ room.is_private|yesno:"true,false" }};
const togglePrivacyBtn = document.getElementById('togglePrivacyBtn');
const privacyPasswordForm = document.getElementById('privacyPasswordForm');
const privacyPasswordInput = document.getElementById('privacyPasswordInput');
const privacyStatus = document.getElementById('privacy-status');
const privacyError = document.getElementById('privacyError');

if (togglePrivacyBtn) {
    togglePrivacyBtn.addEventListener('click', () => {
        if (roomIsPrivate) {
            updateRoomPrivacy({ is_private: 'false' });
        } else if (privacyPasswordForm) {
            privacyPasswordForm.style.display = 'block';
            if (privacyError) {
                privacyError.style.display = 'none';
                privacyError.textContent = '';
            }
            if (privacyPasswordInput) {
                privacyPasswordInput.value = '';
                privacyPasswordInput.focus();
            }
        }
    });
}

if (privacyPasswordForm) {
    privacyPasswordForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!privacyPasswordInput) {
            return;
        }
        const value = privacyPasswordInput.value.trim();
        if (!value) {
            if (privacyError) {
                privacyError.textContent = 'Password is required.';
                privacyError.style.display = 'block';
            }
            return;
        }
        await updateRoomPrivacy({ is_private: 'true', password: value });
    });
}

// Fetch timer state from server
async function fetchTimerState() {
    try {
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/timer/state/`);
        const state = await response.json();
        updateTimerDisplay(state);
    } catch (error) {
        console.error('Error fetching timer state:', error);
    }
}

function updateTimerDisplay(state) {
    const minutes = Math.floor(state.time_left / 60);
    const seconds = state.time_left % 60;
    
    // Update display
    document.getElementById('timer-display').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    // Update mode
    const modeText = state.mode === 'work' ? 'Work Session' : 'Break Time';
    document.getElementById('timer-mode').textContent = modeText;
    document.getElementById('timer-display').style.color = 
        state.mode === 'work' ? '#2563eb' : '#16a34a';
    
    // Update button visibility (only for creator)
    if (IS_CREATOR) {
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        
        if (state.is_running) {
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'block';
        } else {
            startBtn.style.display = 'block';
            pauseBtn.style.display = 'none';
        }
    }
    
    // Play notification when mode changes
    if (lastMode !== state.mode && state.time_left === state.duration) {
        playNotificationSound();
        const message = state.mode === 'work' ? 
            'Break finished! Time to work!' : 
            'Work session finished! Take a break!';
        
        // Show notification
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Pomodoro Timer', { body: message });
        } else {
            alert(message);
        }
    }
    lastMode = state.mode;
}

async function updateRoomPrivacy(payload) {
    if (!togglePrivacyBtn) {
        return;
    }

    if (privacyError) {
        privacyError.style.display = 'none';
        privacyError.textContent = '';
    }

    const formData = new FormData();
    Object.entries(payload).forEach(([key, value]) => formData.append(key, value));

    try {
        const response = await fetch(privacyEndpoint, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
            },
            body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.success) {
            if (privacyError) {
                privacyError.textContent = data.error || 'Unable to update privacy settings.';
                privacyError.style.display = 'block';
            }
            return;
        }
        window.location.reload();
    } catch (error) {
        if (privacyError) {
            privacyError.textContent = 'Unable to update privacy settings.';
            privacyError.style.display = 'block';
        }
        console.error('Error updating privacy:', error);
    }
}

async function startTimer() {
    if (!IS_CREATOR) return;
    
    try {
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/timer/start/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });
        const state = await response.json();
        updateTimerDisplay(state);
    } catch (error) {
        console.error('Error starting timer:', error);
    }
}

async function pauseTimer() {
    if (!IS_CREATOR) return;
    
    try {
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/timer/pause/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });
        const state = await response.json();
        updateTimerDisplay(state);
    } catch (error) {
        console.error('Error pausing timer:', error);
    }
}

async function resetTimer() {
    if (!IS_CREATOR) return;
    
    try {
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/timer/reset/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });
        const state = await response.json();
        updateTimerDisplay(state);
    } catch (error) {
        console.error('Error resetting timer:', error);
    }
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function playNotificationSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
    } catch (e) {
        console.log('Audio notification not supported');
    }
}

// Initialize everything when page loads
window.addEventListener('DOMContentLoaded', () => {
    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
    
    // Initial timer fetch
    fetchTimerState();
    
    // Poll every second for timer updates
    pollInterval = setInterval(fetchTimerState, 1000);
    
    // Real-time chat initialization
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    
    if (messageForm) {
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const content = messageInput.value.trim();
            if (!content) {
                return;
            }
            
            // Clear input immediately for better UX
            messageInput.value = '';
            
            // Send message
            await sendMessage(content);
        });
    }
    
    // Initialize last message ID
    updateLastMessageId();
    
    // Convert initial template-rendered message timestamps to local timezone
    const initialTimestamps = document.querySelectorAll('[data-timestamp-iso]');
    initialTimestamps.forEach(element => {
        const isoString = element.getAttribute('data-timestamp-iso');
        if (isoString) {
            const timestampElement = element.querySelector('.message-timestamp');
            if (timestampElement) {
                timestampElement.textContent = formatTimestamp(isoString);
            }
        }
    });
    
    // Initial message fetch
    fetchMessages();
    
    // Poll for new messages every 1.5 seconds
    messagePollInterval = setInterval(fetchMessages, 1500);
});

// Clean up polling when leaving page
window.addEventListener('beforeunload', () => {
    if (pollInterval) {
        clearInterval(pollInterval);
    }
    if (messagePollInterval) {
        clearInterval(messagePollInterval);
    }
});

// -----------------------------
// REAL-TIME CHAT FUNCTIONALITY
// -----------------------------

// Format timestamp from UTC ISO string to local timezone
function formatTimestamp(utcString) {
    const date = new Date(utcString);
    return date.toLocaleString('en-US', {
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        month: 'short',
        day: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

// Track last message ID to only show new messages
function updateLastMessageId() {
    const messageElements = document.querySelectorAll('[data-message-id]');
    if (messageElements.length > 0) {
        const ids = Array.from(messageElements).map(el => parseInt(el.getAttribute('data-message-id')));
        lastMessageId = Math.max(...ids);
    } else {
        lastMessageId = null;
    }
}

// Fetch messages from server
async function fetchMessages() {
    try {
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/messages/`);
        const data = await response.json();
        updateChatMessages(data.messages);
    } catch (error) {
        console.error('Error fetching messages:', error);
    }
}

// Update chat messages display
function updateChatMessages(messages) {
    const chatContainer = document.getElementById('chat-messages');
    const noMessagesP = document.getElementById('no-messages');
    
    // Get existing message IDs from DOM
    const existingIds = new Set(
        Array.from(document.querySelectorAll('[data-message-id]'))
            .map(el => parseInt(el.getAttribute('data-message-id')))
    );
    
    // Get fetched message IDs from server
    const fetchedIds = new Set(messages.map(msg => msg.id));
    
    // Remove messages that no longer exist in the fetched list (real-time deletion)
    existingIds.forEach(msgId => {
        if (!fetchedIds.has(msgId)) {
            const messageElement = document.querySelector(`[data-message-id="${msgId}"]`);
            if (messageElement) {
                messageElement.remove();
            }
        }
    });
    
    // Show "no messages" text if no messages exist
    if (messages.length === 0 && !document.getElementById('no-messages')) {
        const noMsgP = document.createElement('p');
        noMsgP.id = 'no-messages';
        noMsgP.textContent = 'No messages yet. Start the conversation!';
        chatContainer.appendChild(noMsgP);
    }
    
    // Remove "no messages" text if we have messages
    if (messages.length > 0 && noMessagesP) {
        noMessagesP.remove();
    }
    
    // Add new messages that don't already exist
    let hasNewMessages = false;
    messages.forEach(msg => {
        if (!existingIds.has(msg.id)) {
            addMessageToChat(msg);
            hasNewMessages = true;
        }
    });
    
    // Auto-scroll to bottom if new messages were added
    if (hasNewMessages) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }
}

// Add a single message to the chat
function addMessageToChat(msg) {
    const chatContainer = document.getElementById('chat-messages');
    const noMessagesP = document.getElementById('no-messages');
    
    // Remove "no messages" text if it exists
    if (noMessagesP) {
        noMessagesP.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.setAttribute('data-message-id', msg.id);
    
    const isOwn = msg.is_own;
    messageDiv.style.cssText = `margin-bottom:15px;padding:10px 15px;border-radius:10px;max-width:70%;word-wrap:break-word;position:relative;
        ${isOwn ? 'background-color:#2563eb;color:white;margin-left:auto;' : 'background-color:#e5e7eb;color:#111;'}`;
    
    let deleteButton = '';
    if (isOwn) {
        deleteButton = `
            <button type="button" 
                    onclick="deleteMessage(${msg.id})"
                    style="background-color:transparent;border:none;color:white;cursor:pointer;font-size:18px;padding:0;line-height:1;margin-left:10px;"
                    title="Delete message">
                ×
            </button>`;
    }
    
    // Format timestamp to local timezone
    const formattedTimestamp = formatTimestamp(msg.timestamp);
    
    messageDiv.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:start;">
            <div style="flex:1;">
                <strong>${escapeHtml(msg.user)}</strong><br>
                ${escapeHtml(msg.content)}
                <div style="font-size:0.8em;${isOwn ? 'color:#e0e0e0;' : 'color:#555;'}margin-top:4px;">
                    ${escapeHtml(formattedTimestamp)}
                </div>
            </div>
            ${deleteButton}
        </div>`;
    
    chatContainer.appendChild(messageDiv);
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Send message via AJAX
async function sendMessage(content) {
    try {
        const formData = new FormData();
        formData.append('content', content);
        formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
        
        const response = await fetch(`/studybuddy/room/${ROOM_ID}/send-message/`, {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Message will be picked up by polling, but we can add it immediately for instant feedback
            addMessageToChat(data.message);
            const chatContainer = document.getElementById('chat-messages');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        } else {
            console.error('Error sending message:', data.error);
            alert('Failed to send message. Please try again.');
        }
    } catch (error) {
        console.error('Error sending message:', error);
        alert('Failed to send message. Please try again.');
    }
}

// Delete message via AJAX (real-time deletion)
async function deleteMessage(messageId) {
    if (!confirm('Delete this message?')) {
        return;
    }
    
    try {
        const formData = new FormData();
        formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
        
        // Create a form submission via fetch to match Django's expected POST
        const response = await fetch(`/studybuddy/message/${messageId}/delete/`, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        });
        
        // Remove message from DOM immediately for instant feedback
        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            messageElement.remove();
        }
        
        // Check if we need to show "no messages" text
        const chatContainer = document.getElementById('chat-messages');
        const remainingMessages = chatContainer.querySelectorAll('[data-message-id]');
        if (remainingMessages.length === 0) {
            const noMsgP = document.createElement('p');
            noMsgP.id = 'no-messages';
            noMsgP.textContent = 'No messages yet. Start the conversation!';
            chatContainer.appendChild(noMsgP);
        }
        
        // Next poll will confirm the deletion from server
        // If deletion failed on server, the message will reappear on next poll
    } catch (error) {
        console.error('Error deleting message:', error);
        alert('Failed to delete message. Please try again.');
    }
}

// Clean up message polling when leaving page
window.addEventListener('beforeunload', () => {
    if (messagePollInterval) {
        clearInterval(messagePollInterval);
    }
});
</script>
{% endblock %}
